# Wiki module for mozbot. 
#
# if Told 'wiki $foo', will wiki for 'foo' and return either n lines
# of output, or if more than one match, a list of matches.

package BotModules::Wiki;
use LWP::UserAgent;
use vars qw(@ISA);
@ISA = qw(BotModules);
1;

# RegisterConfig - Called when initialised, should call registerVariables
sub RegisterConfig {
    my $self = shift;
    $self->SUPER::RegisterConfig(@_);
    $self->registerVariables(
			   # [ name, save?, settable? ]
			     ['baseUrl',       1, 1, ''],
			     ['searchUrl',     1, 1, ''],
			     ['linesToJibber', 1, 1, 5 ],
			     ['wikiLoc',       1, 1, ''],
			     ['wikiRealm',     1, 1, ''],
			     ['wikiUser',      1, 1, ''],
			     ['wikiPass',      1, 1, ''],
			    );
}

sub Help {
    my $self = shift;
    my ($event) = @_;
    local $";
    $" = '|';
    return {
        '' => 'Goes and looks stuff up in a Wiki',
        'wiki' => "do a wiki search for something"
    };
}

sub Told {
    my $self = shift;
    my ($event, $message) = @_;
    if ($message =~ /^\s*wiki\s+(.*?)\s*$/osi) {
        $self->Wiki($event, $1);
    } else {
        return $self->SUPER::Told(@_);
    }
    return 0; # dealt with it...
}

sub wiki_do {
    my $self = shift;
    my ($event, $searchterm) = @_;

    $self->debug("firing LWP get for $self->{searchUrl}$searchterm");
    my $ua = LWP::UserAgent->new(env_proxy => 1,
				 keep_alive => 1,
				 timeout => 30,
				);
    $ua->credentials($self->{wikiLoc},$self->{wikiRealm},$self->{wikiUser},$self->{wikiPass});
    my $request = HTTP::Request->new('GET', $self->{searchUrl} . $searchterm);
    my $response = $ua->request($request);
    my $result = $response->content;

    if (!defined $result) {
	return "$event->{'from'}: something about querying the wiki is broken (LWP get failed)";
    }

    # parse wiki page
    my @matches;
    my $content;

    my $num_matches = scalar @matches;
    if ($num_matches > 1) {
        return "$event->{'from'}: ".($num_matches)." matches: " . (join ', ', @matches);
    } elsif ($num_matches == 1) {
	my @content = split /\n/, $content;
	return
	  "$event->{'from'}: 1 match:\n" . 
	  join "\n", @content[0 .. ($self->{linesToJibber} - 1)] . 
	  "(more information at ".$self->{baseUrl}."$searchterm)";
    } elsif ($num_matches == 0) {
	return "$event->{'from'}: nothing matching $searchterm in the Wiki.";
    } else {
	return "$event->{'from'}: something *really* *weird* is broken with querying the Wiki (-ve no. matches).";
    }
}

# ChildCompleted - Called when a child process has quit
sub ChildCompleted {
    my $self = shift;
    my ($event, $type, $output, @data) = @_;
    if ($type eq 'wiki') {
        $self->say($event, $output);
    } else {
        $self->SUPER::ChildCompleted($event, $type, $output, @data);
    }
}

sub Wiki {
    my $self = shift;
    my ($event, $wiki) = @_;

    # check things are ok.
    if (!defined $wiki) {
        $self->say($event, "$event->{'from'}: You can't search the Wiki for nothing.");
        return;
    }

    $self->spawnChild($event, \&wiki_do, [$self, $event, $wiki], 'wiki', []);
}

sub doWiki {
my ($wikiquery) = @_;
my $wikianswer="";
my $row;
my $id;
my $pagename;
my $text="";
my $counter;
my $unique="NO";
my $uniqueid;

$wikiquery=~s/[ \?]*$//g ; #Zap trailing space(s) or question mark(s)

my $dbh = DBI->connect("DBI:mysql:phpwiki:172.16.1.254","funkbot",undef);

$dbh or die "Unable to connect to wiki Database: $dbh->errstr\n";
my $sth = $dbh->prepare("SELECT id,pagename FROM page WHERE pagename = ?");

$sth->execute($wikiquery) or die "Unable to execute query: $dbh->errstr\n";
my $count = $sth->rows;
if ($count==1) {
$row = $sth->fetchrow_arrayref;
$unique="YES";
$uniqueid=$row->[0];
$sth->finish;
}
print "Unique =".$unique." id=".$uniqueid." count=".$count;
$sth = $dbh->prepare("SELECT id,pagename FROM page WHERE upper(pagename) like upper(concat('%',?,'%'))");
$sth->execute($wikiquery) or die "Unable to execute query: $dbh->errstr\n";
$count = $sth->rows;


if ($count == 1) {
        $row = $sth->fetchrow_arrayref;
        $id = $row->[0];
} elsif ($count > 1) {
        my $n=0;
        $counter=$count;
        while($n++<10 && $counter-- && ($row = $sth->fetchrow_arrayref)) {
        $text.=$row->[1].", ";
}
if($counter > 0) {
        $text.="and $counter more";
} else {
        substr($text,-2)="";
}
}
$sth->finish;
if ($count == 0) {
        $wikiquery=~ s/ /%20/g;
        $wikianswer="Couldn't find it in the Wiki\nMaybe you should add it at http://wiki.lemonia.org/index.php?pagename=".$wikiquery ;
} elsif ($count == 1) {
        $sth = $dbh->prepare("SELECT content FROM version WHERE id = ? order by version desc limit 1");
        $sth->execute($id) or die "Unable to execute query: $dbh->errstr\n";
        $row = $sth->fetchrow_arrayref;
        if ($unique eq "NO") {
        $wikianswer=$row->[0];
}
        $sth->finish;
} elsif ($count > 1) {
        $wikianswer=$count." hits : ".$text;
}
if ($unique eq "YES") {
        $sth = $dbh->prepare("SELECT content FROM version WHERE id = ? order by version desc limit 1");
        $sth->execute($uniqueid) or die "Unable to execute query: $dbh->errstr\n";
        $row = $sth->fetchrow_arrayref;
        $wikiquery=~ s/ /%20/g;

        $wikianswer=$row->[0];
        my @lines = split /\n/, $wikianswer;
        my @no_blanks = grep { $_ ne '' } @lines;
        $wikianswer = join "\n", @no_blanks[0..5];
        $wikianswer = "Exact match : ".$wikiquery."\n".$wikianswer."\nMore information available at http://wiki.lemonia.org/index.php?pagename=".$wikiquery;
        #$wikianswer=~s/\n\\s+\n/\n/g ; #Zap whitespace
        #$wikianswer=~s/\n*/\n/g ; #Zap more whitespace

        $sth->finish;
}
        $dbh->disconnect;

        return $wikianswer;
}

